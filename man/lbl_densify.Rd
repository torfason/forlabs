% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/densify.R
\name{lbl_densify}
\alias{lbl_densify}
\title{Densify a labelled vector}
\usage{
lbl_densify(x, unlabelled = c("error", "fill"))
}
\arguments{
\item{x}{A labelled vector to be densified.}

\item{unlabelled}{This parameter determines the handling of unlabelled values
in the input vector. It can take two values:
\itemize{
\item "error": Throw an error if there are unlabelled values in the vector.
\item "fill": Fill in labels for any unlabelled values using \code{\link[=lbl_fill]{lbl_fill()}}
before densifying.
}}
}
\value{
A labelled vector of the same length as the original vector, \code{x}, but
with values replaced with their dense ranks. The labels are correctly
associated with their respective values and the variable label (if present)
is preserved.
}
\description{
The \code{lbl_densify} function takes a labelled vector and assigns new,
densely-ranked integer values to each unique value in the vector. The order
of the unique values is preserved. This function keeps the labels correctly
associated with their respective values throughout the densifying process.

The sub-type (\code{typeof(x)}) of the labelled is preserved for \code{double} and
\code{integer}, but \code{character} variables (\verb{<labelled<character>>}) are not
supported as densification is not applicable for character strings.
}
\examples{
  # Densify the veggies vector
  lbl_densify(veggies)

  # Densify exotic_veggies, filling in for unlabelled values
  lbl_densify(exotic_veggies, unlabelled = "fill")

}
